<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WebXR 이중 나선 + Seed</title>
<style>
  html, body { margin:0; height:100%; background:#000; }
  #ui { position:fixed; left:10px; top:10px; background:rgba(0,0,0,.7); color:#fff; padding:10px; border-radius:8px; z-index:10; }
  #pointsCanvas { position:fixed; right:10px; top:10px; width:300px; height:300px; background:#111; border:1px solid #333; }
</style>
</head>
<body>
<div id="ui">
  <button id="startBtn">시작</button>
  <button id="stopBtn">중지</button>
  <button id="enterVR">VR 시작</button>
  <div id="status">상태: 점 0/4</div>
</div>
<canvas id="pointsCanvas"></canvas>
<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { VRButton } from "https://unpkg.com/three@0.160.0/examples/jsm/webxr/VRButton.js";

// Three.js 기본 세팅
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
camera.position.set(0,1.6,3);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);

// VR 버튼
const vrBtn = VRButton.createButton(renderer);
document.getElementById('enterVR').addEventListener('click', ()=>{
  document.body.appendChild(vrBtn);
  vrBtn.click();
});

// ===== Seed 생성 =====
let points=[];
function computeSeed(){
  let s=0;
  points.forEach((p,i)=>{ s^=((p.x+p.y)|0)<<(i%16); });
  return (s>>>0)||0x9e3779b9;
}
function mulberry32(a){ return function(){let t=a+=0x6D2B79F5; t=Math.imul(t^(t>>>15),t|1); t^=t+Math.imul(t^(t>>>7),t|61); return((t^(t>>>14))>>>0)/4294967296; } }

let rng=mulberry32(0x1234abcd);

// ===== 점 입력 =====
const pCanvas=document.getElementById('pointsCanvas');
const pCtx=pCanvas.getContext('2d');
pCanvas.width=300; pCanvas.height=300;
function drawPoints(){
  pCtx.fillStyle='#111';
  pCtx.fillRect(0,0,300,300);
  points.forEach(p=>{ pCtx.fillStyle='#ff0'; pCtx.beginPath(); pCtx.arc(p.x,p.y,6,0,Math.PI*2); pCtx.fill(); });
}
function addPoint(x,y){
  if(points.length<4){
    points.push({x,y});
    drawPoints();
    document.getElementById('status').textContent=`상태: 점 ${points.length}/4`;
    if(points.length===4){
      const seed=computeSeed();
      rng=mulberry32(seed);
      document.getElementById('status').textContent=`상태: 점 ${points.length}/4 (seed=0x${seed.toString(16)})`;
    }
  }
}
pCanvas.addEventListener('click',e=>{
  const rect=pCanvas.getBoundingClientRect();
  addPoint(e.clientX-rect.left, e.clientY-rect.top);
});
drawPoints();

// ===== 이중 나선 + 양쪽 기울기 =====
let running=false;
const groupA=[], groupB=[];

function createHelices(){
  const seg=200;
  const geom=new THREE.BufferGeometry();
  geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(seg*3),3));
  const lineA=new THREE.Line(geom.clone(), new THREE.LineBasicMaterial({color:0xff0000}));
  const lineB=new THREE.Line(geom.clone(), new THREE.LineBasicMaterial({color:0x00ffff}));
  scene.add(lineA); scene.add(lineB);
  groupA.push(lineA); groupB.push(lineB);
}

createHelices();

function updateHelices(time){
  const seg=200; const height=4.0; const stepY=height/seg; const r=0.5;
  const posA=groupA[0].geometry.attributes.position.array;
  const posB=groupB[0].geometry.attributes.position.array;

  let pA=0,pB=0;
  for(let s=0;s<seg;s++){
    const y=-height/2+s*stepY;
    const angle=time*1.5+0.2*s;
    // 오른쪽 기울기 나선
    posA[pA++]=Math.cos(angle)*r+0.2; // x offset +0.2
    posA[pA++]=y;
    posA[pA++]=Math.sin(angle)*r;
    // 왼쪽 기울기 나선
    posB[pB++]=Math.cos(angle+Math.PI)*r-0.2; // x offset -0.2
    posB[pB++]=y;
    posB[pB++]=Math.sin(angle+Math.PI)*r;
  }
  groupA[0].geometry.attributes.position.needsUpdate=true;
  groupB[0].geometry.attributes.position.needsUpdate=true;
}

const clock=new THREE.Clock();
function animate(){
  renderer.setAnimationLoop(()=>{
    if(running){
      updateHelices(clock.getElapsedTime());
    }
    renderer.render(scene,camera);
  });
}
animate();

// 버튼 동작
document.getElementById('startBtn').onclick=()=>{running=true;};
document.getElementById('stopBtn').onclick=()=>{running=false;};

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
